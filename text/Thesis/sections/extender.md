[https://developer.ibm.com/articles/creating-a-custom-kube-scheduler/](Source)

## Four ways to extend Kubernetes Scheduler
- Modify Upstream Source code, recompile and run scheduler
- Separate Scheduler, that runs a long (scales bad, such as a distributed lock and cache synchronization)
- scheduler extender
- scheduler framework

## How the scheduler extender works
How does the scheduler function?
- scheduler starts with parameters give
- watches pods with empty .spec.nodeName puts them in a queue
- pops out a pod from the queue and starts scheduling cycle
- filter (based on hard requirements, etc)
- score (soft requirement)
- bind (api server)

## What is an Extender
Extender is a set of API endpoints
- /filter
  Filter based on extender-implemented predicate functions. The filtered list is expected to be a subset of the supplied list. The failedNodes and failedAndUnresolvableNodes optionally contains the list of failed nodes and failure reasons, except nodes in the latter are unresolvable.
  - Arguments: Pod + List of Nodes
  - Expects: List of Nodes (subset of Input Nodes)
- /prioritize
 Prioritize based on extender-implemented priority functions. The returned scores & weight are used to compute the weighted score for an extender. The weighted scores are added to the scores computed by Kubernetes scheduler. The total scores are used to do the host selection.
 - Arguments: Pod + List of Nodes
 - Expects: List of Nodes with Scores + Weight
- /bind
 Delegates binding
 - Arguments: Binding (which is essentially Pod + TargetNode)
 - Expects: Error if occured
- /preempt
 ProcessPreemption returns nodes with their victim pods processed by extender based on given:
 1. Pod to schedule
 2. Candidate nodes and victim pods (nodeNameToVictims) generated by the previous scheduling process.
 The possible changes made by extender may include:
