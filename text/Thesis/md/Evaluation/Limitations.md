The prototype implementation of the External-Scheduler-Interface comes along with limitations. This section will outline a few of them. The final Future Work Section will be a continuation of this section.
This section focuses more on limitations and problems encountered during Testing. The Future Work section picks up on features that were not feasible for a prototype in the given time frame.

One of the biggest problems, which created the most trouble, is the locking Mechanism. Locking is required because concurrent use of the Testbed is unreliable. The problem is that slot reservations do not happen instantaneously but rather after the pods are scheduled, leaving the Testbed in a seemingly empty state, wherein reality slots have already been used by a Scheduling creating batch jobs. This also leads to a somewhat awkward design of the Schedulings state machine. Scheduling has to wait for confirmation of its previous scheduling cycle before the Testbeds slot occupation status is updated. The locking mechanism also creates the drawback of potential deadlocks. Finalizers are used to release claimed jobs and testbeds once Scheduling is deleted.

Another commonly encountered problem is dealing with errors. Due to poorly written software or unexpected cluster changes, errors were frequently encountered. One of Kubernetes' core aspects is self-healing, where control-loops move the cluster from a damaged state back into a healthy state. Kubernetes native resources like Jobs have policies for automatic restarting. 
On the Interfaces side, error detection is handled by the resources state machine. The state machine approach is supposed to eliminate frequent checks for preconditions. If a precondition fails, the resource moves into a failed state. The current implementation does not handle failures particularly well, and Batch Jobs encountering errors will remain in the failed state until recreated.  
