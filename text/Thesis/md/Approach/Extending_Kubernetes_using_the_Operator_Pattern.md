The smallest unit of *deployment* in Kubernetes is a Pod[@kubernetesPodDocs]. While a Pod may consist of multiple containers, containers in a Pod are guaranteed to run on the same Node.
Containers in Pods also share storage and network resources across the container boundary. In General, containers inside the same Pod are tightly coupled and commonly used in a sidecar pattern to extend the main container with common functionalities across the cluster, like the Kube-RBAC-Proxy[@rbacProxy] that is frequently used with Containers that interact with the Kubernetes API and require authorization.

Usually, in Kubernetes, Pods are not created by themself but are managed by resources that build on top of them. Most commonly, Pods are used in Combination with Jobs, Deployments, or Statefulsets, which control the Lifecycle of the Pod.

The Operator pattern is based on the already existing design used by Kubernetes native Resources like Deployments the *Control-Loop*. Resources like Jobs, Deployments[@kubernetesDeploymentsDocs], and Statefulsets[@kubernetesStatefulSetsDocs] describe Pods' desired state. Essentially Kubernetes has controllers that monitor changes to the Resources Manifest and the current cluster situation. 
The Control-Loop (or Reconciler-Loop) allows a Deployment consisting of a Pod template with a Replication-Factor to the exact amounts of Pods running inside the cluster. If any of the Pods fails, the Deployment Controller creates a new one. The controller ensures that new Pods are created first and become ready before old Pods are deleted. But on the Flip-Side, the controller also knows when the Resources Manifest is updated. For example, if the container is updated to a more recent version, all containers need to be replaced with the newer version. Deployment Resources have many policies that dictate how these actions should happen. Usually, restarting all Pods at once would not be desired so that the deployment would allow for Rolling-Upgrades.

Using multiple controllers, that each intern only is concerned with a single resource creates a very loosely coupled and thus highly extendible interface. The Idea of a reconciliation controller loop improves the resiliency of a system by observing the current state, comparing it to the desired state, and taking actions for the observed state to converge into the desired state.[@burns2016borg]

The Operator Pattern is commonly used to extend Kubernetes Functionalities. Most of the time, however, just creating a new controller is not enough to extend Kubernetes. It usually also requires Custom Resource Definitions.
Custom Resource Definitions (CRD) is the Kubernetes way of defining new resources that are allowed to exist in the cluster. Having multiple Controllers listing to the same Resource, like a Deployment, makes little sense or could even cause issues. Thus the Combination of a new Resource and a Controller that knows how to handle it creates the *Operator Pattern*. The term *Operator* is used as the controller is designed to replace previously manual work of configuring Kubernetes native Resources done by an Operator. An everyday use case for the Operator Pattern is to Control Applications at a Higher level, where previously Multiple Deployments and Services may have been required to operate a Database. The Operator Pattern could reduce that to just a single Manifest containing the meaningful configuration. Operators can thus be created by Experts operating the Software and be used by any Kubernetes Cluster.

Common best practices when developing Operators are that operators should only manage a single kind of resources, and multiple operators should be used if multiple resources need to be managed.
Rather than micro-managing resources down to the creation of Pods, operators should delegate to existing operators where ever possible, e.g., using Kubernetes native resources, like Deployments. Multiple operators should not act on the same CRD, as this requires synchronization between operators and enforces tight coupling between components. Since all operators work with the Kubernetes API, many identical boiler code has been written over the years, and many best practices are contained inside opinionated frameworks. [@OperatorSdkBestPractice]