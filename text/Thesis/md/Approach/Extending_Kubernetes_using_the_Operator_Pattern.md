A complete introduction into the core concepts of Kubernetes does not fit in the scope of this thesis. Commonly used concepts of Kubernetes, like *Deployments*, *ReplicaSets*, *Jobs*, and *DaemonSets* are already well documented [@kubernetesStatefulSetsDocs; @kubernetesDeploymentsDocs].

The smallest unit of deployable software in Kubernetes is a Pod [@kubernetesPodDocs]. While a Pod may consist of multiple containers, containers in a Pod are guaranteed to run on the same Node.
Containers in Pods also share storage and network resources across the container boundary. In general, containers inside the same Pod are tightly coupled and commonly used in a sidecar pattern to extend the main container with common functionalities across the cluster, like the Kube-RBAC-Proxy [@rbacProxy] that is frequently used with containers that interact with the Kubernetes API and require authorization.

Usually, in Kubernetes, Pods are not created by themself but are managed by resources that build on top of them. Most commonly, Pods are used in combination with Jobs, Deployments, or StatefulSets, which control the lifecycle of the Pod.

![ReplicaSet observes and controls the state of Pods](graphics/replicaset.pdf){#fig:replicatSetDiagram short-caption="ReplicaSet Control Loop"}

The Operator pattern is based on the already existing design used by Kubernetes native resources, the *control loop*. Resources like Jobs, Deployments [@kubernetesDeploymentsDocs], and ReplicaSets [@kubernetesStatefulSetsDocs] describe a desired state of Pods. Controllers take control over resources and manage them automatically. Controllers are not tied to the lifetime of a particular resource, but they exist and monitor the cluster state at all times in a control loop. Figure @fig:replicatSetDiagram demonstrates the control loop of the ReplicaSet controller. As the name implies, the ReplicaSet controller manages ReplicaSet resources, consisting of a pod template with the number of replicas. The ReplicatSet controller makes sure that the exact amount of Pods that correspond to the template are healthily running. If any of the Pods fails, the ReplicaSets controller deletes it and creates a new one. The controller also knows if the resources manifest is updated and updates the replication of the Pod accordingly. 

Other Kubernetes resources like Deployments are built on top of ReplicaSets. The Deployment manages ReplicatSets to create the desired replication. If the Deployment is updated to a more recent version, all containers need to be replaced with the newer version. Restarting all Pods at once would leave the application in an inaccessible state. Deployments support many policies that dictate how these actions should happen. A common policy for Deployment is a rolling deployment, where old Pods coexist with new Pods until all new Pods are healthily running. The Deployment creates an additional ReplicaSet for the new version and simultaneously decrements the old ReplicaSet for each new Pod.

Using multiple controllers, of which each is only concerned with a single resource, creates a very loosely coupled and thus highly extendible interface. The idea of a reconciliation controller loop improves the resiliency of a system by observing the current state, comparing it to the desired state, and taking actions for the observed state to converge into the desired state [@burns2016borg].

The Operator pattern is commonly used to extend Kubernetes functionalities. Most of the time, however, just creating a new controller is not enough to extend Kubernetes. It usually also requires Custom Resource Definitions (CRDs).
A CRD is the Kubernetes way of defining new resources that are allowed to exist in the cluster. Having multiple controllers listing to the same resource, like a Deployment, makes little sense or could even cause issues. Thus the combination of a new CRD and a controller that knows how to handle it creates the *Operator pattern*. The term Operator is used as the controller is designed to replace previously manual work of configuring Kubernetes native resources done by an Operator. An everyday use case for the Operator pattern is to control applications at a higher level, where previously multiple deployments and services may have been required to operate a database. The Operator pattern could reduce that to just a single manifest containing the meaningful configuration. Operators can thus be created by experts operating the software and be used by any Kubernetes cluster.

Common best practices when developing Operators are that Operators should only manage a single kind of resource, and multiple Operators should be used if multiple resources need to be managed.
Rather than micro-managing resources down to the creation of Pods, Operators should delegate to existing Operators where ever possible, e.g., using Kubernetes native resources, like Deployments. Multiple Operators should not act on the same CRD, as this requires synchronization between Operators and enforces tight coupling between components. Since all Operators work with the Kubernetes API, a lot of identical boiler code has been written over the years, and many best practices are contained inside opinionated frameworks [@OperatorSdkBestPractice]. Operators implemented in the context of this thesis are using the Java Operator SDK.